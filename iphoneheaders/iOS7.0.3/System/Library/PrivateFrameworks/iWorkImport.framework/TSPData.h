/*
* This header is generated by strong_classdump 0.1
* on Wednesday, November 27, 2013 at 12:09:25 AM Eastern European Standard Time
* Operating System: Version 7.0.3 (Build 11B511)
* Image Source: /System/Library/PrivateFrameworks/iWorkImport.framework/iWorkImport
* strong_classdump is Copyright Â© 2013 by Elias Limneos, licensed under GPLv3.
*/

#import <iWorkImport/iWorkImport-Structs.h>
#import <iWorkImport/TSPSplitableData.h>

@protocol OS_dispatch_queue, TSPDataStorage;
@class NSObject, , NSString, TSPDataManager, TSPObjectContext;

@interface TSPData : NSObject <TSPSplitableData> {

	long long _identifier;
	NSObject<OS_dispatch_queue>* _accessQueue;
	<TSPDataStorage>* _storage;
	NSString* _filename;
	TSPDataManager* _manager;
	array<unsigned char, 20> _digest;
	BOOL _isCulling;

}

@property (nonatomic,readonly) NSString * filename; 
@property (nonatomic,readonly) NSString * type; 
@property (nonatomic,readonly) BOOL isReadable; 
@property (nonatomic,readonly) BOOL isApplicationData; 
@property (nonatomic,readonly) BOOL isExternalData; 
@property (nonatomic,readonly) NSString * documentResourceLocator; 
@property (nonatomic,readonly) NSString * packageLocator; 
@property (nonatomic,readonly) unsigned char packageIdentifier; 
@property (nonatomic,readonly) TSPObjectContext * context; 
@property (nonatomic,readonly) NSString * uniqueName; 
@property (nonatomic,readonly) BOOL needsDownload; 
@property (nonatomic,readonly) unsigned long long encodedLength; 
@property (nonatomic,readonly) long long identifier;                            //@synthesize identifier=_identifier - In the implementation block
@property (nonatomic,retain) <TSPDataStorage> * storage; 
+(id)dataFromReadChannel:(id)arg1 filename:(id)arg2 context:(id)arg3 ;
+(BOOL)updateDigest:(array<unsigned char, 20>*)arg1 withProtobufString:(const basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >*)arg2 ;
+(id)dataFromURL:(id)arg1 useExternalReferenceIfAllowed:(BOOL)arg2 context:(id)arg3 ;
+(id)cullingListenersQueue;
+(id)cullingListeners;
+(id)requiredAVAssetOptions;
+(id)dataFromURL:(id)arg1 context:(id)arg2 ;
+(id)dataFromNSData:(id)arg1 filename:(id)arg2 context:(id)arg3 ;
+(id)dataFromDataRep:(id)arg1 filename:(id)arg2 context:(id)arg3 ;
+(id)readOnlyDataFromURL:(id)arg1 ;
+(id)readOnlyDataFromNSData:(id)arg1 filename:(id)arg2 ;
+(void)addCullingListener:(id)arg1 ;
+(void)removeCullingListener:(id)arg1 ;
+(void)dataForAssetsLibraryURL:(id)arg1 context:(id)arg2 queue:(id)arg3 completion:(/*^block*/ id)arg4 ;
+(id)pasteboardTypeForIdentifier:(long long)arg1 ;
+(id)null;
-(BOOL)needsDownload;
-(const array<unsigned char, 20>*)digest;
-(id)storage;
-(id)packageLocator;
-(unsigned char)packageIdentifier;
-(void)performIOChannelReadWithAccessor:(/*^block*/ id)arg1 ;
-(BOOL)isStorageInPackage:(id)arg1 ;
-(BOOL)gilligan_isRemote;
-(void)setStorage:(id)arg1 ;
-(void)setFilename:(id)arg1 storage:(id)arg2 ;
-(id)initWithIdentifier:(long long)arg1 digest:(const array<unsigned char, 20>*)arg2 filename:(id)arg3 storage:(id)arg4 manager:(id)arg5 ;
-(BOOL)isApplicationData;
-(CGDataProviderRef)newCGDataProvider;
-(CGImageSourceRef)newCGImageSource;
-(id)AVAssetWithOptions:(id)arg1 ;
-(BOOL)isLengthLikelyToBeGreaterThan:(unsigned long long)arg1 ;
-(id)documentResourceLocator;
-(id)NSData;
-(void)archiveInfoMessage:(DataInfo*)arg1 archiver:(id)arg2 ;
-(id)bookmarkData;
-(CGImageRef)newCGImage;
-(BOOL)isExternalData;
-(id)copyWithContext:(id)arg1 ;
-(void)performInputStreamReadWithAccessor:(/*^block*/ id)arg1 ;
-(void)addDownloadObserver:(id)arg1 completionHandler:(/*^block*/ id)arg2 ;
-(id)pasteboardType;
-(void)splitDataWithMaxSize:(unsigned long)arg1 subdataHandlerBlock:(/*^block*/ id)arg2 ;
-(id)preferredFilename;
-(id)AVAsset;
-(void)dealloc;
-(BOOL)isEqual:(id)arg1 ;
-(unsigned)hash;
-(id)description;
-(id)type;
-(id)context;
-(long long)identifier;
-(id).cxx_construct;
-(id)uniqueName;
-(BOOL)isReadable;
-(unsigned long long)encodedLength;
-(id)UIImage;
-(id)filename;
-(BOOL)writeToURL:(id)arg1 error:(id*)arg2 ;
-(void).cxx_destruct;
@end

